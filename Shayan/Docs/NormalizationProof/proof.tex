\documentclass[a4paper]{article}
%%\usepackage{lua-visual-debug}
\usepackage[round]{natbib}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mathtools}
\usepackage[pdfauthor={Shayan Najd},pdftitle={Modular Lazy Normaliser},pagebackref=true,pdftex]{hyperref}
\usepackage{titling}
\usepackage{pbox}
\usepackage{tabularx}
\usepackage{amsthm}
\usepackage{enumerate}

\newcommand{\incolor}[1]{#1}    % Use to typeset in color
%\newcommand{\incolor}[1]{}     % Use to typeset in black and white
 
% color framework

\newcommand{\judgecolor}{}
\newcommand{\typecolor}{}
\newcommand{\termcolor}{}
\newcommand{\Typecolor}{}
\newcommand{\Termcolor}{}

\newcommand{\uncolored}{
  \incolor{
    \renewcommand{\judgecolor}{}
    \renewcommand{\typecolor}{}
    \renewcommand{\termcolor}{}
    \renewcommand{\Typecolor}{}
    \renewcommand{\Termcolor}{}
  }
}

\newcommand{\colored}{
  \incolor{
    \renewcommand{\judgecolor}{\color{black}}
    \renewcommand{\typecolor}{\color{blue}}
    \renewcommand{\termcolor}{\color{red}}
    \renewcommand{\Typecolor}{\color{cyan}}
    \renewcommand{\Termcolor}{\color{magenta}}
  }
}

\newcommand{\jd}[1]{{\judgecolor #1}}
\newcommand{\tp}[1]{{\typecolor #1}}
\newcommand{\tm}[1]{{\termcolor #1}}
\newcommand{\Tp}[1]{{\Typecolor #1}}
\newcommand{\Tm}[1]{{\Termcolor #1}}

\newcommand{\tmof}[1]{\tm{#1:{}}}
\newcommand{\Tmof}[1]{\Tm{#1:{}}}
\newcommand{\tmsem}[1]{\tm{\sem{\Tm{#1}}}}
\newcommand{\tpsem}[1]{\tp{\sem{\Tp{#1}}}}
\newcommand{\tmSem}[1]{{\termcolor \left\llbracket
                        \judgecolor #1
                        \termcolor \right\rrbracket}}


%%
\newenvironment{note}{\begin{trivlist} \item \textbf{Note. }}{\end{trivlist}}
\newcommand{\todo}[1]{\textbf{#1}}
\newcommand{\etal}{\emph{et~al.}}
\newcommand{\inference}[3]{\infer[\mathsf{#2}]{#3}{#1}}
\newcommand{\Inference}[3]{\infer=[\mathsf{#2}]{#3}{#1}}
\newcommand{\spacer}{\quad\quad\quad\quad}
\newcommand{\filler}{\hspace{0.9\textwidth}}
\newcommand{\tighten}{\vspace{-1ex}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{scheme}[theorem]{Proposition Scheme}
\newtheorem{definition}{Definition}
\newcommand{\hole}{[\ ]}
\newcommand{\intro}{\mathcal{I}}
\newcommand{\elim}{\mathcal{E}}

%% Types
\newcommand{\typvar}[1]{#1}
\newcommand{\typzro}{\mathbf{0}}
\newcommand{\typone}{\mathbf{1}}
\newcommand{\typarr}[2]{#1\boldsymbol{\rightarrow}#2}
\newcommand{\typprd}[2]{#1\boldsymbol{\times}#2}
\newcommand{\typsum}[2]{#1\boldsymbol{+}#2}
\newcommand{\typrec}[2]{\boldsymbol{\mu}#1\boldsymbol{.}#2}

%% Expressions
\newcommand{\expvar}[1]{#1}
\newcommand{\expunt}{\boldsymbol{()}}
\newcommand{\expabs}[3]{\boldsymbol{\lambda}\,#1\boldsymbol{\colon}#2\boldsymbol{.}\ #3}
\newcommand{\expapp}[2]{#1\ #2}
\newcommand{\expshr}[3]{\mathbf{let}\ #1\boldsymbol{=}#2\ \mathbf{in}\ #3} 
\newcommand{\expshrind}[3]{\begin{array}[t]{@{}l@{}}\mathbf{let}\ #1\boldsymbol{=}#2\\ \mathbf{in}\ \ #3\end{array}} 
\newcommand{\expprd}[2]{\boldsymbol{(}#1\ \boldsymbol{,}\ #2\boldsymbol{)}}
\newcommand{\expfst}[1]{\mathbf{fst}\ #1}
\newcommand{\expsnd}[1]{\mathbf{snd}\ #1}
\newcommand{\explft}[2]{\mathbf{inl}\ #1\ #2}
\newcommand{\exprgt}[2]{\mathbf{inr}\ #1\ #2}
\newcommand{\expcas}[5]{\mathbf{case}\ #1\ \mathbf{of}\ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}}
\newcommand{\expcasind}[5]{\begin{array}[t]{@{}l@{}}\mathbf{case}\ #1\ \mathbf{of}\\[-1pt] \ \ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}\end{array}}
\newcommand{\expcasindind}[5]{\begin{array}[t]{@{}l@{}}\mathbf{case}\ #1\ \mathbf{of}\\[-1pt] \ \ \ \ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \\[-1pt] \ \ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}\end{array}}

%% Environment
\newcommand{\envemp}{\tp{\boldsymbol{\emptyset}}}
\newcommand{\envcon}[2]{\tp{#1,}\ #2}
\newcommand{\env}{\tp{\Gamma}}
\newcommand{\typing}[2]{\tm{#1:\ }\tp{#2}}

\newcommand{\typenvcon}[2]{\tp{\Gamma,}\ \typing{#1}{#2}}
\newcommand{\sbs}[3]{#1[#2:=#3]}
\newcommand{\fv}[1]{\txt{FV}\,(#1)}
\newcommand{\txt}[1]{\text{\textit{#1}}}
\newcommand{\rewrite}[3]{#1 \overset{#2}\mapsto #3} 
\newcommand{\reduce}[3]{#1 \overset{#2}\rightarrow #3} 
\newcommand{\reducestar}[3]{#1 \overset{#2}\twoheadrightarrow #3} 
\newcommand{\valuep}[1]{\txt{Value}\,(#1)}
\newcommand{\cnd}[1]{\begin{array}[t]{@{}l@{}}\txt{if}\ #1\end{array}}
\newcommand{\subformulae}[1]{\txt{Subformulae}\,(#1)}
\newcommand{\psubformulae}[1]{\txt{ProperSubformulae}\,(#1)}
\newcommand{\subterm}[1]{\txt{Subterm}\,(#1)}
\newcommand{\norm}[1]{\txt{Norm}\,(#1)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\setlength{\belowcaptionskip}{0pt}
\setlength{\abovecaptionskip}{0pt}
\setlength{\droptitle}{0pt} 
\addtolength{\droptitle}{-60pt}
\addtolength{\textheight}{50pt}
\addtolength{\textwidth}{125pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
%%\setlength{\marginparsep}{0pt}
%%\setlength{\marginparwidth}{0pt}

\makeatletter
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother

\begin{document}
\title{Modular Lazy Normalisation}
\author{Shayan Najd}
\maketitle 
\section*{Introduction}
In this article, I sketch design of a ``modular lazy normalisation''
algorithm.

The normalisation algorithm takes as input an expression and returns a
``semantically equivalent'' expression in ``normal form''. In
particular, we are interested in a normal form where all
$\beta$-redexes, including the ones related to data destructors, are
eliminated.

Normalisation algorithm is ``lazy'' in the sense that elimination of
redexes does not duplicate expressions; it preserves sharing.

Normalisation algorithm is ``modular'' in the sense that the same
algorithm can be applied to a family of languages. Members of
the mentioned family of languages differ only in their set of built-in
functions and built-in types.

\section*{Step I -- No Polymorphism}
Variables are distinct set of names. Metavariables $x$, $y$, and $z$
range over variables. Wherever variables are used, renaming of bound
variables is allowed; presentations are valid up to renamings.  

Types are \textbf{closed} terms defined by the abstract syntax in
Figure~\ref{fig:typ}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{llll}
A,B,C & \mathbin{\ ::=\ } 
%% & \tp{\typvar{X}}        & \textrm{variable}     \\
%% & \ |\ \ 
         & \typone       & \textrm{unit}         \\
& \ |\ \ & \typarr{A}{B} & \textrm{abstraction}  \\
& \ |\ \ & \typprd{A}{B} & \textrm{product}      \\
& \ |\ \ & \typsum{A}{B} & \textrm{sum}       %% \\
%% & \ |\ \ & \tp{\typrec{X}{T}} & \textrm{recursion} 
\end{array}
\]\caption{Types}
\label{fig:typ}
\end{figure*}

Metavariables $A$, $B$, and $C$ range over types. Types
correspond to formule in minimal propositional logic. 
%% and we restrict them to occure strictly
%% positive:
%% \todo{definition of strictly positive here}  
%% With exception of the recursion type, 
%% The recursion type is included to be able
%% to encode a wide range of datatypes which are otherwise built-in in
%% the language; every monomorphic datatype can be viewed as a recursive
%% sums of products. This general encoding enables us to provide
%% generic normalisation rules for data destructors. The generic rules
%% need to only consider three data destructors: two destructors for
%% products and one for sums. Since all data destructors are a combination
%% of the mentioned three data destructors, their corresponding
%% $\delta$-redexes are combinations of $\delta$-redexes corresponding to
%% the three data destructors. Therefore, by cooking in a set of
%% normalisation rules to eliminate $\delta$-redexes corresponding to the
%% three data destructors, we gaurantee removal of all $\delta$-redexes
%% corresponding to data destructors; there is no need to provide and
%% build in a separate set of $\delta-$reduction rules per each datatype.
 
Expressions are \textbf{open} terms defined by the abstract syntax in
Figure~\ref{fig:exp}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{llll}
L,M,N & \mathbin{\ ::=\ } 
         & \expvar{x}             & \textrm{variable}          \\
& \ |\ \ & \expunt                & \textrm{unit}              \\
& \ |\ \ & \expabs{x}{A}{N}      & \textrm{abstraction}       \\
& \ |\ \ & \expapp{L}{M}          & \textrm{application}       \\
& \ |\ \ & \expshr{x}{M}{N}       & \textrm{sharing}           \\
& \ |\ \ & \expprd{M}{N}          & \textrm{product}           \\
& \ |\ \ & \expfst{L}             & \textrm{projection-first}  \\
& \ |\ \ & \expsnd{L}             & \textrm{projection-second} \\ 
& \ |\ \ & \explft{M}{\tm{B}}     & \textrm{injection-left}    \\
& \ |\ \ & \exprgt{\tm{A}}{N}     & \textrm{injection-right}   \\
& \ |\ \ & \expcas{L}{x}{M}{y}{N} & \textrm{case}           
\end{array}
\]
\caption{Expressions}
\label{fig:exp}
\end{figure*}
 
Metavariables $L$, $M$, and $N$ range over expressions. Expressions
correspond to proofs in minimal propositional logic.

%Erasing the types, colored in red, yields the usual untyped
%$\lambda$-calculus.

Capture-free subsititution is defined as usual and it is denoted as
$\sbs{N}{x}{M}$ for subtitution of the expression $M$ for the variable
$x$ in the expression $N$. Set of free variables in an expression is
calculated as usual and it is denote as $\fv{N}$ for set of free
variables in $N$. Moreover, notation $count(x,N)$ is used to denote a
metafunction returning the number of times the free variable $x$ is
used syntactically in the expression $N$.
% We follow Barendregt convension such that we assume variables in a
% term are all distinct. 
Typing %, normalisation, and evaluation 
 environments are all maps from
variable names. The metavariables $\Gamma$, and $\Delta$ range over
environments.  The inference rules are equivalent up to exchange,
contraction, and weakening operations. 

Typing relations, denoted as $:$ infix operator, are defined by
the inference rules in Figure~\ref{fig:typing}.

\begin{figure*}[h]
\[\colored
\begin{array}{ll}
\fbox{$\env \vdash \typing{M}{A}$}
\\~\\
\inference
{}
{\mathbf{Ax}}
{
  \typenvcon{x}{A} \vdash \typing{x}{A}
}
&
\inference
{}
{\typone}
{
   \env \vdash \typing{\expunt}{\typone}
}
\\~\\
\inference
{
  \typenvcon{x}{A} \vdash \typing{N}{B} 
}
{{\to}\intro}
{
  \env \vdash \typing{\expabs{x}{A}{N}}{\typarr{A}{B}}
}
&
\inference
{
  \env \vdash \typing{L}{\typarr{A}{B}} 
& \env \vdash \typing{M}{A} 
}
{{\to}\elim}
{
  \env \vdash \typing{\expapp{L}{M}}{B} 
}
\\~\\ 
\inference
{
  \env \vdash \typing{M}{A}
  &
  \typenvcon{x}{A} \vdash \typing{N}{B}
}
{\mathbf{let}}
{
  \env \vdash \typing{\expshr{x}{M}{N}}{B}
}
&
\inference
{
  \env \vdash \typing{M}{A}
  & 
  \env \vdash \typing{N}{B} 
}
{{\times}\intro}
{
  \env \vdash \typing{\expprd{M}{N}}{\typprd{A}{B}} 
}
\\~\\ 
\inference
{
  \env \vdash \typing{L}{\typprd{A}{B}} 
}
{{\times}\elim_1}
{
  \env \vdash \typing{\expfst{L}}{A}
}
&
\inference
{
  \env \vdash \typing{L}{\typprd{A}{B}} 
}
{{\times}\elim_2}
{
  \env \vdash \typing{\expsnd{L}}{B}
}
\\~\\
\inference
{
  \env \vdash \typing{M}{A}
}
{{+}\intro_1}
{
  \env \vdash \typing{\explft{M}{B}}{\typsum{A}{B}}
}
&
\inference
{
  \env \vdash \typing{N}{B} 
}
{{+}\intro_2}
{
  \env \vdash \typing{\exprgt{A}{N}}{\typsum{A}{B}}
}
\\~\\
\inference
{
  \env \vdash \typing{L}{\typsum{A}{B}} 
& 
  \typenvcon{x}{A} \vdash \typing{M}{C}  
& 
  \typenvcon{y}{B} \vdash \typing{N}{C}
}
{{+}\elim}
{
  \env \vdash \typing{\expcas{L}{x}{M}{y}{N}}{C} 
} 
\end{array}
\]
\caption{Typing Rules}
\label{fig:typing}
\end{figure*}

Typing rules are syntax-directed and algorithmic. The consistency of
the type system can be established by its correspondence (under
Curry-Howard) to minimal logic. The correspondece is made evident by
using colored fonts in typing rules; removing the red bits
(i.e. expressions) from the typing rules yields the corresponding
logical inference rules.\\

Values are expressions that do not compute and they follow the abstract syntax in Figure~\ref{fig:val}.

\begin{figure*}[h]
\[\uncolored
\begin{array}[t]{lll} 
V,W & \mathbin{\ ::=\ } & \expvar{x}\ |\ \expabs{x}{A}{W}\ |\ \expunt\ |\ \expprd{V}{W}\ |\ \explft{V}{B}\ |\ \exprgt{A}{W}
\end{array}
\] 
\caption{Values}
\label{fig:val}
\end{figure*} 

The metavariables $V$, and $W$ range over values. The notation
$\valuep{N}$ is used to denote a predicate indicating whether the
expression $N$ is a value.

%% \begin{figure*}[h]
%% \[\uncolored
%% \begin{array}{lll}

%% \fbox{$\valuep{N}$}
%% \\~\\
%% \inference
%% {}
%% {variable}
%% {
%%   \valuep{\expvar{x}}
%% }
%% &
%% \inference
%% {}
%% {unit}
%% {
%%   \valuep{\expunt}
%% }
%% &
%% \inference
%% {
%% }
%% {abstraction}
%% {
%%   \valuep{\expabs{x}{A}{N}}
%% }
%% \\~\\
%% \inference
%% {
%%   \valuep{M} 
%%   &
%%   \valuep{N} 
%% }
%% {product}
%% {
%%   \valuep{\expprd{M}{N}}
%% }
%% &
%% \inference
%% { 
%%   \valuep{M} 
%% }
%% {injection-left}
%% {
%%   \valuep{\explft{M}{B}}
%% }
%% &
%% \inference
%% { 
%%   \valuep{N} 
%% }
%% {injection-right}
%% {
%%   \valuep{\exprgt{A}{N}}
%% }
%% \end{array}
%% \]
%% \caption{Values}
%% \label{fig:val}
%% \end{figure*}
  
Operational semantics is defined in Figure~\ref{fig:red}. The rewrite
rules are denoted as $\rewrite{}{}{}$. One-step reduction relaion,
denoted as $\reduce{}{}{}$, is compatible closure of rewrite
rules. Reduction relation, denoted as $\reducestar{}{}{}$, is
reflexive transitive closure of the one-step reduction relation. The
metavariables $F$ and $G$ denote capture-allowing evaluation frames,
used in rewrite rules. The metafunctions defined for expressions carry
over to evaluation frames trivially.
    
\begin{figure*}[h]
\[\uncolored
\begin{array}{@{}l@{}}
F \mathbin{\ ::=\ } \expapp{\hole}{M}\ |\ \expshr{x}{\hole}{N}\ |\ \expfst{\hole}\ |\ \expsnd{\hole}\ |\ \expcas{\hole}{x}{M}{y}{N}
\\[2pt]
G \mathbin{\ ::=\ } \explft{\hole} \ |\ \exprgt{\hole}\ |\ \expprd{\hole}{N}\ |\ \expprd{V}{\hole} %% ,\ \txt{if}\ \valuep{M}
\\[2pt]

\begin{array}[t]{@{}ll@{\ \rewrite{}{}{}\ \ }ll@{}} 
(let_{\rightarrow})  
& \expapp{(\expabs{x}{A}{N})}{M} 
& \expshr{x}{M}{N} 
& \\[0pt]  

(let_{+/\times})
& G[M]
& \expshr{x}{M}{G[x]}
& \cnd{x\ \txt{is\ fresh}}\\[0pt]

(\beta_{\times_1})  
& \expfst{\expprd{V}{W}} 
& V
& \\[0pt]

(\beta_{\times_2})  
& \expsnd{\expprd{V}{W}} 
& W                                               
& \\[0pt]

(\beta_{+_1}) 
& \expcasind{(\explft{V}{B})}{x}{M}{y}{N}
& \sbs{M}{x}{V} 
& \\[0pt]

(\beta_{+_2})  
& \expcasind{(\exprgt{A}{W})}{x}{M}{y}{N}
& \sbs{N}{y}{W}
& \\[0pt]

(\beta_{let}) 
& \expshr{x}{V}{N}
& \sbs{N}{x}{V}  
& \\[0pt]

(need) 
& \expshr{x}{M}{N}
& \sbs{N}{x}{M}  
& \cnd{Count(x,N) < 2,\ and\\\ \ \ \neg\valuep{M}}\\[0pt]

(\kappa_{case})
& F[\expcasind{L}{x}{M}{y}{N}]
& \expcasind{L}{x}{F[M]}{y}{F[N]}
& \cnd{x \notin \fv{F},\ and\\\ \ \ y \notin \fv{F}}  \\[0pt]

(\kappa_{let})
& F[\expshr{x}{L}{M}]
& \expshr{x}{L}{F[M]} 
& \cnd{x \notin \fv{F}} \\[0pt]
\end{array}
\end{array}
\]
\caption{Reduction Rules}
\label{fig:red}
\end{figure*} 

\begin{proposition}[Confluency of Rewrite Rules]\ \\
\label{prop_confluency}
The rewrite rules in Figure~\ref{fig:red} form a confluent rewrite theory.
\end{proposition}

\begin{definition}[Normal Form]\ \\
An expression $M$ is in normal form, denoted as $\norm{M}$, if and only
if, does not exist an expression $N$ such that $\reduce{M}{}{N}$.
\end{definition}

\begin{proposition}[Normal Form Syntax]\ \\
\label{prop_normal}
An expression $M$ is in normal form, if and only if, it follows the
abstract syntax in Figure~\ref{fig:nf}, by the entry $P$.
\end{proposition}
 
\begin{figure*}[h]
\[\uncolored
\begin{array}[t]{llll} 
(\txt{Neutral Forms}) & S & \mathbin{\ ::=\ } & \expvar{x}\ |\ R
\\
(\txt{Non-Value Neutral Forms}) & R & \mathbin{\ ::=\ } & \expapp{S}{P}\ |\ \expfst{S}\ |\ \expsnd{S}
\\
(\txt{Value Normal Forms}) & T,U & \mathbin{\ ::=\ } & \expvar{x}\ |\ \expabs{x}{A}{Q}\ |\ \expunt\ |\ \expprd{T}{U}\ |\ \explft{T}{B}\ |\ \exprgt{A}{U}
\\
(\txt{Normal Forms}) & P,Q & \mathbin{\ ::=\ } & T\ |\ R\ |\ \expcas{S}{x}{P}{y}{Q} \\
& & \ | & \expshr{x}{R}{Q} %% ,\ \txt{if}\ count(x,Q)\geq2
\end{array}
\] 
\caption{Normal Forms}
\label{fig:nf}
\end{figure*} 

\begin{proposition}[Preservation]\ \\
\label{prop_preservation}
One-step reduction preserves the type of the source expression:
 
 if $\env \vdash \typing{M}{A}$ and $\reduce{M}{}{N}$, then 
$\env \vdash \typing{N}{A}$.
\end{proposition}

\begin{definition}[Subterms]\ \\
The set of subterms of a term is defined trivially based on its
syntax. Subterms of an expression term are called subexpressions of
the expression term.  Subterms of a type term are called subformula of
the type term, denoted as $\subformulae{\_}$.  Union of subformulae of all
types in a typing environment is also called subformulae of the
environment, denoted as $\subformulae{\_}$.
\end{definition}

\begin{definition}[Proper Subterms]\ \\
A set of subterms of a term that does not include the term itself is
called the set of proper subterms. The set of proper subexpressions,
and proper subformulae, denoted as $\psubformulae{\_}$, are defined
in the same manner.
\end{definition}

\begin{lemma}\ \\
\label{sub_S}
Provided an expression of neutral form, i.e. syntactic category $S$,
and an environment, type of the expression is in the set of
subformulae of types in the environment:
 
 if $\env \vdash \typing{S}{A}$, then $A \in \subformulae{\Gamma}$.
\end{lemma}

\begin{proof}
Provided an expression of neutral form and environment $\Gamma$,
by structural induction on the expression, we have the following cases:
\begin{description}
\item[Case ($\expvar{x}$):]\ \\ 
  The corresponding typing derivation concludes the result.
\item[Case ($R$):]\ \\
  Lemma~\ref{sub_R} concludes the result.   
\end{description}

\end{proof}

\begin{lemma}\ \\
\label{sub_R}
Provided an expression of non-value neutral form, i.e. syntactic
category $R$, and an environment, type of the expression is in the set
of subformulae of types in the environment:
 
 if $\Gamma \vdash \typing{R}{A}$, then $A \in \subformulae{\Gamma}$.
\end{lemma}

\begin{proof}
Provided an expression of non-value neutral form and environment
$\Gamma$, by structural induction on the expression, we have the following cases:
\begin{description}
\item[Case ($\expapp{S}{P}$):]\ \\ 
  By the corresponding typing derivation and lemma~\ref{sub_S}, we
  have $\typarr{A}{B} \in \subformulae{\Gamma}$, where $\typarr{A}{B}$
  is type of $S$ and $B$ type of the whole expression. Since, by the
  definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
  \item  $B \in \subformulae{\typarr{A}{B}}$,
  \end{enumerate}
  it concludes the result.
\item[Case ($\expfst{S}$):]\ \\
  By the corresponding typing derivation and lemma~\ref{sub_S}, we
  have $\typprd{A}{B} \in \subformulae{\Gamma}$, where $\typprd{A}{B}$
  is type of $S$ and $A$ type of the whole expression. Since, by the
  definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
  \item $A \in \subformulae{\typprd{A}{B}}$,
  \end{enumerate}
  it concludes the result.
\item[Case ($\expsnd{S}$):]\ \\
  By the corresponding typing derivation and lemma~\ref{sub_S}, we
  have $\typprd{A}{B} \in \subformulae{\Gamma}$, where $\typprd{A}{B}$
  is type of $S$ and $B$ type of the whole expression. Since, by the
  definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
  \item $B \in \subformulae{\typprd{A}{B}}$,
  \end{enumerate}
  it concludes the result.
\end{description}
\end{proof}

\begin{lemma}\ \\
\label{sub_V}
Provided an expression of value normal form, i.e. syntactic
category $T$, type of each subrexpression inside the expression is
either in the set of subformulae of the type of the expression, or in
the set of subformulae of types in the environment:

 if $\Gamma \vdash \typing{T}{A}$, then for every subexpression $T_i$
 in $T$, such that $\Delta \vdash \typing{T_i}{A_i}$, we have $A_i \in
 \subformulae{A}$ or $A_i \in \subformulae{\Gamma}$. 
\end{lemma}
\begin{proof}
Provided an expression of value normal form and environment $\Gamma$,
by structural induction on the expression, we have the following cases:
\begin{description}
\item[Case ($\expvar{x}$):]\ \\ 
  The corresponding typing derivation concludes the result. 
\item[Case ($\expabs{x}{A}{Q}$):]\ \\ 
  By the corresponding typing derivation and lemma~\ref{sub_P}, we
  have for every $A_i$ (type of the subexpression $Q_i$ in $Q$), that
  $A_i \in \subformulae{(\typenvcon{x}{A})}$, or $A_i \in
  \subformulae{B}$, where $\typarr{A}{B}$ is type of the whole
  expression. Since, by the definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
     \item $(A_i \in \subformulae{A})$ or $(A_i \in \subformulae{B})$ implies $A_i \in \subformulae{\typarr{A}{B}}$, and
     \item $A_i \in \subformulae{(\typenvcon{x}{A})}$ implies $(A_i \in \subformulae{\Gamma})$ or $(A_i \in \subformulae{A})$;
  \end{enumerate}
  it concludes the result.
\item[Case ($\expunt$):]\ \\ 
  The corresponding typing derivation concludes the result. 
\item[Case ($\expprd{T}{U}$):]\ \\ 
  By the corresponding typing derivation and lemma~\ref{sub_V}
  (i.e. the induction hypothesis), we have for every $A_i$ (type of
  the subexpression $T_i$ in $T$), that $A_i \in
  \subformulae{\Gamma}$, or $A_i \in \subformulae{A}$, where
  $\typprd{A}{B}$ is type of the whole expression. We also have for
  every $B_i$ (type of the subexpression $U_i$ in $U$), that $B_i \in
  \subformulae{\Gamma}$, or $B_i \in \subformulae{B}$. Since, by the
  definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
     \item $A_i \in \subformulae{A}$ implies $A_i \in \subformulae{\typprd{A}{B}}$, and
     \item $B_i \in \subformulae{B}$ implies $B_i \in \subformulae{\typprd{A}{B}}$;
  \end{enumerate}
  it concludes the result.
\item[Case ($\explft{T}{B}$):]\ \\
  By the corresponding typing derivation and lemma~\ref{sub_V}
  (i.e. the induction hypothesis), we have for every $A_i$ (type of
  the subexpression $T_i$ in $T$), that $A_i \in
  \subformulae{\Gamma}$, or $A_i \in \subformulae{A}$,
  where $\typsum{A}{B}$ is type of the whole expression.
  Since, by the definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
     \item $A_i \in \subformulae{A}$ implies $A_i \in \subformulae{\typsum{A}{B}}$,
  \end{enumerate}
  it concludes the result. 
\item[Case ($\exprgt{A}{U}$):]\ \\
  By the corresponding typing derivation and lemma~\ref{sub_V}
  (i.e. the induction hypothesis), we have for every $B_i$ (type of
  the subexpression $U_i$ in $U$), that $B_i \in
  \subformulae{\Gamma}$, or $B_i \in \subformulae{B}$,
  where $\typsum{A}{B}$ is type of the whole expression.
  Since, by the definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
     \item $B_i \in \subformulae{B}$ implies $B_i \in \subformulae{\typsum{A}{B}}$,
  \end{enumerate}
  it concludes the result.
\end{description}
\end{proof}

\begin{lemma}\ \\
\label{sub_P}
Provided an expression of normal form, i.e. syntactic category $P$,
type of each subrexpression inside the expression is either in the set of
subformulae of the type of the expression, or in the set
of subformulae of types in the environment:

 if $\Gamma \vdash \typing{P}{A}$, then for every subexpression $P_i$
 in $P$, such that $\Delta \vdash \typing{P_i}{A_i}$, we have $A_i \in
 \subformulae{A}$ or $A_i \in \subformulae{\Gamma}$. 
\end{lemma}
\begin{proof}
Provided an expression of normal form and environment $\Gamma$,
by structural induction on the expression, we have the following cases:
\begin{description}
\item[Case ($T$):]\ \\
  Lemma~\ref{sub_V} concludes the result.
\item[Case ($R$):]\ \\
  Lemma~\ref{sub_R} concludes the result.
\item[Case ($\expcas{S}{x}{P}{y}{Q}$):]\ \\
  By the corresponding typing derivation and lemma~\ref{sub_S}, we
  have $\typsum{A}{B} \in \subformulae{\Gamma}$. We also have,
  together with lemma~\ref{sub_P} (i.e. the induction hypothesis), for
  every $A_i$ (type of the subexpression $P_i$ in $P$), that $A_i \in
  \subformulae{\typenvcon{x}{A}}$, or $A_i \in \subformulae{C}$, where
  $C$ is type of the whole expression. Moreover, we have, together
  with lemma~\ref{sub_P} (i.e. the induction hypothesis), for every
  $B_i$ (type of the subexpression $Q_i$ in $Q$), that $B_i \in
  \subformulae{\typenvcon{x}{B}}$, or $B_i \in \subformulae{C}$.
  Since, by the definition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
     \item $\typsum{A}{B} \in \subformulae{\Gamma}$ implies $(A \in \subformulae{\Gamma})$ and $(B \in \subformulae{\Gamma})$,
     \item $A_i \in \subformulae{\typenvcon{x}{A}}$ implies $(A_i \in \subformulae{\Gamma})$ or $(A_i \in \subformulae{A})$, and
     \item $B_i \in \subformulae{\typenvcon{x}{B}}$ implies $(B_i \in \subformulae{\Gamma})$ or $(B_i \in \subformulae{B})$; 
  \end{enumerate}
  it concludes the result. 
\item[Case ($\expshr{x}{R}{Q}$):]\ \\
  By the corresponding typing derivation and lemma~\ref{sub_R}, we
  have $A \in \subformulae{\Gamma}$, where $A$ is type of $R$. We also
  have, together with lemma~\ref{sub_P} (i.e. the induction
  hypothesis), for every $B_i$ (type of the subexpression $Q_i$ in
  $Q$), that $B_i \in \subformulae{\typenvcon{x}{A}}$, or $B_i \in
  \subformulae{B}$, where $B$ is type of the whole expression. Since, by the defition of $\subformulae{}$, we have
  \begin{enumerate}[(a)] 
     \item $B_i \in \subformulae{\typenvcon{x}{A}}$ implies $(B_i \in \subformulae{\Gamma})$ or $(B_i \in \subformulae{A})$,
  \end{enumerate}
  it concludes the result.
\end{description}
\end{proof}

\begin{proposition}[Subformula Property]\ \\
\label{prop_subformula}
If $\Gamma \vdash \typing{N}{A}$, $\reducestar{N}{}{Q}$, and $\norm{Q}$;
then for every expression $Q_i$ in the set of subexpressions of $Q$ such
that $\Delta \vdash \typing{Q}{A_i}$, $A_i$ is in the set of subformulae of
the type $A$, or in the set of subformulae of all types in the
environment $\Gamma$.
\end{proposition}
\begin{proof}
Proof is done by using proposition~\ref{prop_preservation},
propostion~\ref{prop_normal}, and lemma~\ref{sub_P}.
\end{proof}

So far, we have proven the subformula property for the calculus;
however, we require some stronger properties in practice. For
instance, consider the situation where normalised terms in our
higher-order language is compiled to terms of a first-order
language. In such a scenario, we would like to provide a form of
gaurantee at compile-time, indicating absence of lambda abstractions
in a normalised term. Therefore, we start by formulating the following
proposition scheme, parameterised over a predicate on the typing
environment.

\begin{scheme}[$\Phi-$Strong Subformula Property]\ \\
\label{sub_scheme}
Provided the predicate $\Phi(\_)$, expression $N$, and environment
$\Gamma$ such that $\Phi(\Gamma)$; if $\Gamma \vdash \typing{N}{A}$,
$\reducestar{N}{}{Q}$, and $\norm{Q}$; then for every expression $Q_i$
in the set of subexpressions of $Q$ such that $\Delta \vdash
\typing{Q_i}{A_i}$, $A_i$ is in the set of subformulae of the type
$A$.
\end{scheme}

Now, we start with a simple predicate to only allow closed expressions.
 
\begin{proposition}[Nil$-$Strong Subformula Property]\ \\
Having $\Phi(\_)$ instantiated to $\Phi(\envemp)$ (i.e. accepting empty environments only), the
proposition~scheme~\ref{sub_scheme} holds.
\end{proposition}
\begin{proof}
The proposition~\ref{prop_subformula} concludes the proof.
\end{proof}

\textbf{Warning: the remaning is only a sketch, possibly non-sense!}

\begin{definition}[Rank$_n$]\ \\
Rank$_n$ type is a type that only allows each type constructor inside
it to be nested inside itself no more than $n - 1$ times. Similarly,
rank$_{n}^{\,\circledast}$ type is a type, inside which nesting of the
type constructor $\circledast$ is restricted to maximum $n - 1$ times.
For example, rank$_{0}^{\,\typarr{}{}}$ type is a type that does not have
function type $\typarr{}{}$ anywhere inside it.
\end{definition}

\begin{proposition}[Rank$_{1}-$Strong Subformula Property]\ \\
Having $\Phi(\Gamma)$ instantiated to the following statement, the
proposition~scheme~\ref{sub_scheme} holds:
 
 forall type $A_i$ in $\Gamma$, $A_i$ is of rank$_{1}$.
 
\end{proposition}
\begin{proof}
To be investigated...
\end{proof}

 
\end{document}
