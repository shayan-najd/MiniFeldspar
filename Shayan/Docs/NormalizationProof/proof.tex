\documentclass[11p,a4paper]{article}
%%\usepackage{lua-visual-debug}
\usepackage[round]{natbib}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mathtools}
\usepackage[pdfauthor={Shayan Najd},pdftitle={Modular Lazy Normaliser},pagebackref=true,pdftex]{hyperref}
\usepackage{titling}
\usepackage{pbox}
\usepackage{tabularx}
\usepackage{amsthm}
\usepackage{enumerate}

\newcommand{\incolor}[1]{#1}    % Use to typeset in color
%\newcommand{\incolor}[1]{}     % Use to typeset in black and white
 
% color framework

\newcommand{\judgecolor}{}
\newcommand{\typecolor}{}
\newcommand{\termcolor}{}
\newcommand{\Typecolor}{}
\newcommand{\Termcolor}{}

\newcommand{\uncolored}{
  \incolor{
    \renewcommand{\judgecolor}{}
    \renewcommand{\typecolor}{}
    \renewcommand{\termcolor}{}
    \renewcommand{\Typecolor}{}
    \renewcommand{\Termcolor}{}
  }
}

\newcommand{\colored}{
  \incolor{
    \renewcommand{\judgecolor}{\color{black}}
    \renewcommand{\typecolor}{\color{blue}}
    \renewcommand{\termcolor}{\color{red}}
    \renewcommand{\Typecolor}{\color{cyan}}
    \renewcommand{\Termcolor}{\color{magenta}}
  }
}

\newcommand{\jd}[1]{{\judgecolor #1}}
\newcommand{\tp}[1]{{\typecolor #1}}
\newcommand{\tm}[1]{{\termcolor #1}}
\newcommand{\Tp}[1]{{\Typecolor #1}}
\newcommand{\Tm}[1]{{\Termcolor #1}}

\newcommand{\tmof}[1]{\tm{#1:{}}}
\newcommand{\Tmof}[1]{\Tm{#1:{}}}
\newcommand{\tmsem}[1]{\tm{\sem{\Tm{#1}}}}
\newcommand{\tpsem}[1]{\tp{\sem{\Tp{#1}}}}
\newcommand{\tmSem}[1]{{\termcolor \left\llbracket
                        \judgecolor #1
                        \termcolor \right\rrbracket}}


%%
\newenvironment{note}{\begin{trivlist} \item \textbf{Note. }}{\end{trivlist}}
\newcommand{\todo}[1]{\textbf{#1}}
\newcommand{\etal}{\emph{et~al.}}
\newcommand{\inference}[3]{\infer[\mathsf{#2}]{#3}{#1}}
\newcommand{\Inference}[3]{\infer=[\mathsf{#2}]{#3}{#1}}
\newcommand{\spacer}{\quad\quad\quad\quad}
\newcommand{\filler}{\hspace{0.9\textwidth}}
\newcommand{\tighten}{\vspace{-1ex}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}{Definition}
\newcommand{\hole}{[\ ]}
\newcommand{\intro}{\mathcal{I}}
\newcommand{\elim}{\mathcal{E}}

%% Types
\newcommand{\typvar}[1]{#1}
\newcommand{\typunt}{\boldsymbol{\top}}
\newcommand{\typarr}[2]{#1\boldsymbol{\rightarrow}#2}
\newcommand{\typprd}[2]{#1\boldsymbol{\times}#2}
\newcommand{\typsum}[2]{#1\boldsymbol{+}#2}
\newcommand{\typrec}[2]{\boldsymbol{\mu}#1\boldsymbol{.}#2}

%% Expressions
\newcommand{\expvar}[1]{#1}
\newcommand{\expunt}{\boldsymbol{\top}}
\newcommand{\expabs}[3]{\boldsymbol{\lambda}\,#1\boldsymbol{\colon}#2\boldsymbol{.}\ #3}
\newcommand{\expapp}[2]{#1\ #2}
\newcommand{\expshr}[3]{\mathbf{let}\ #1\boldsymbol{=}#2\ \mathbf{in}\ #3} 
\newcommand{\expshrind}[3]{\begin{array}[t]{@{}l@{}}\mathbf{let}\ #1\boldsymbol{=}#2\\ \mathbf{in}\ \ #3\end{array}} 
\newcommand{\expprd}[2]{\boldsymbol{(}#1\ \boldsymbol{,}\ #2\boldsymbol{)}}
\newcommand{\expfst}[1]{\mathbf{fst}\ #1}
\newcommand{\expsnd}[1]{\mathbf{snd}\ #1}
\newcommand{\explft}[2]{\mathbf{inl}\ #1\ #2}
\newcommand{\exprgt}[2]{\mathbf{inr}\ #1\ #2}
\newcommand{\expcas}[5]{\mathbf{case}\ #1\ \mathbf{of}\ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}}
\newcommand{\expcasind}[5]{\begin{array}[t]{@{}l@{}}\mathbf{case}\ #1\ \mathbf{of}\\[-1pt] \ \ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}\end{array}}
\newcommand{\expcasindind}[5]{\begin{array}[t]{@{}l@{}}\mathbf{case}\ #1\ \mathbf{of}\\[-1pt] \ \ \ \ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \\[-1pt] \ \ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}\end{array}}

%% Environment
\newcommand{\envemp}{\tp{\boldsymbol{\emptyset}}}
\newcommand{\envcon}[2]{\tp{#1,}\ #2}
\newcommand{\env}{\tp{\Gamma}}
\newcommand{\typing}[2]{\tm{#1:\ }\tp{#2}}

\newcommand{\typenvcon}[2]{\tp{\Gamma,}\ \typing{#1}{#2}}
\newcommand{\sbs}[3]{#1[#2:=#3]}
\newcommand{\fv}[1]{\txt{FV}\,(#1)}
\newcommand{\txt}[1]{\text{\emph{#1}}}
\newcommand{\rewrite}[3]{#1 \overset{#2}\mapsto #3} 
\newcommand{\reduce}[3]{#1 \overset{#2}\rightarrow #3} 
\newcommand{\reducestar}[3]{#1 \overset{#2}\twoheadrightarrow #3} 
\newcommand{\valuep}[1]{\txt{Value}\,(#1)}
\newcommand{\cnd}[1]{\begin{array}[t]{@{}l@{}}\txt{if}\ #1\end{array}}
\newcommand{\subformulae}[1]{\txt{subformulae}\,(#1)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\setlength{\belowcaptionskip}{0pt}
\setlength{\abovecaptionskip}{0pt}
\setlength{\droptitle}{0pt} 
\addtolength{\droptitle}{-60pt}
\addtolength{\textheight}{50pt}
\addtolength{\textwidth}{125pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
%%\setlength{\marginparsep}{0pt}
%%\setlength{\marginparwidth}{0pt}

\begin{document}
\title{Modular Lazy Normalisation}
\author{Shayan Najd}
\maketitle 
\section*{Introduction}
In this article, I sketch design of a ``modular lazy normalisation''
algorithm.

The normalisation algorithm takes as input an expression and returns a
``semantically equivalent'' expression in ``normal form''. In
particular, we are interested in a normal form where all
$\beta$-redexes, and $\delta$-redexes corresponding to data
desctructors are eliminated.

Normalisation algorithm is ``lazy'' in the sense that elimination of
redexes does not duplicate expressions; it preserves sharing.

Normalisation algorithm is ``modular'' in the sense that the same
algorithm can be applied to a family of languages. Members of
the mentioned family of languages differ only in their set of built-in
functions and built-in types.

\section*{Step I -- No Polymorphism}
Variables are distinct set of names. Metavariables $x$, $y$, and $z$
range over variables. Wherever variables are used, renaming of bound
variables is allowed; presentations are valid up to renamings.  

Types are \textbf{closed} terms defined by the abstract syntax in
Figure~\ref{fig:typ}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{llll}
A,B,C,D & \mathbin{\ ::=\ } 
%% & \tp{\typvar{X}}        & \textrm{variable}     \\
%% & \ |\ \ 
         & \typunt       & \textrm{unit}         \\
& \ |\ \ & \typarr{A}{B} & \textrm{abstraction}  \\
& \ |\ \ & \typprd{A}{B} & \textrm{product}      \\
& \ |\ \ & \typsum{A}{B} & \textrm{sum}       %% \\
%% & \ |\ \ & \tp{\typrec{X}{T}} & \textrm{recursion} 
\end{array}
\]\caption{Types}
\label{fig:typ}
\end{figure*}

Metavariables $A$, $B$, $C$, and $D$ range over types. Types correspond to
formule in minimal propositional logic.

%% and we restrict them to occure strictly
%% positive:
%% \todo{definition of strictly positive here}  
%% With exception of the recursion type, 
%% The recursion type is included to be able
%% to encode a wide range of datatypes which are otherwise built-in in
%% the language; every monomorphic datatype can be viewed as a recursive
%% sums of products. This general encoding enables us to provide
%% generic normalisation rules for data destructors. The generic rules
%% need to only consider three data destructors: two destructors for
%% products and one for sums. Since all data destructors are a combination
%% of the mentioned three data destructors, their corresponding
%% $\delta$-redexes are combinations of $\delta$-redexes corresponding to
%% the three data destructors. Therefore, by cooking in a set of
%% normalisation rules to eliminate $\delta$-redexes corresponding to the
%% three data destructors, we gaurantee removal of all $\delta$-redexes
%% corresponding to data destructors; there is no need to provide and
%% build in a separate set of $\delta-$reduction rules per each datatype.
 
Expressions are \textbf{open} terms defined by the abstract syntax in
Figure~\ref{fig:exp}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{llll}
L,M,N & \mathbin{\ ::=\ } 
         & \expvar{x}             & \textrm{variable}          \\
& \ |\ \ & \expunt                & \textrm{unit}              \\
& \ |\ \ & \expabs{x}{A}{N}      & \textrm{abstraction}       \\
& \ |\ \ & \expapp{L}{M}          & \textrm{application}       \\
& \ |\ \ & \expshr{x}{M}{N}       & \textrm{sharing}           \\
& \ |\ \ & \expprd{M}{N}          & \textrm{product}           \\
& \ |\ \ & \expfst{L}             & \textrm{projection-first}  \\
& \ |\ \ & \expsnd{L}             & \textrm{projection-second} \\ 
& \ |\ \ & \explft{M}{\tm{B}}     & \textrm{injection-left}    \\
& \ |\ \ & \exprgt{\tm{A}}{N}     & \textrm{injection-right}   \\
& \ |\ \ & \expcas{L}{x}{M}{y}{N} & \textrm{case}           
\end{array}
\]
\caption{Expressions}
\label{fig:exp}
\end{figure*}
 
Metavariables $L$, $M$, and $N$ range over expressions. Expressions
correspond to proofs in minimal propositional logic.

%Erasing the types, colored in red, yields the usual untyped
%$\lambda$-calculus.

Capture-free subsititution is defined as usual and it is denoted
as $\sbs{N}{x}{M}$ for subtitution of the expression $M$ for the
variable $x$ in the expression $N$. Set of free variables in an
expression is calculated as usual and it is denote as $\fv{N}$ for set
of free variables in $N$. Moreover, notation $count(x,N)$ is used to
denote a metafunction returning the number of times the free variable
$x$ is used in the term $N$.
% We follow Barendregt convension such that we assume variables in a
% term are all distinct. 
Typing, normalisation, and evaluation environments are all maps from
variable names. The metavariables $\Gamma$, and $\Delta$ range over
environments.  The inference rules are equivalent up to exchange,
contraction, and weakening operations.

Typing relations, denoted as $:$ infix operator, are defined by
the inference rules in Figure~\ref{fig:typing}.

\begin{figure*}[h]
\[\colored
\begin{array}{ll}
\fbox{$\env \vdash \typing{M}{A}$}
\\~\\
\inference
{}
{\mathbf{Ax}}
{
  \typenvcon{x}{A} \vdash \typing{x}{A}
}
&
\inference
{}
{\typunt}
{
   \env \vdash \typing{\expunt}{\typunt}
}
\\~\\
\inference
{
  \typenvcon{x}{A} \vdash \typing{N}{B} 
}
{{\to}\intro}
{
  \env \vdash \typing{\expabs{x}{A}{N}}{\typarr{A}{B}}
}
&
\inference
{
  \env \vdash \typing{L}{\typarr{A}{B}} 
& \env \vdash \typing{M}{A} 
}
{{\to}\elim}
{
  \env \vdash \typing{\expapp{L}{M}}{B} 
}
\\~\\ 
\inference
{
  \env \vdash \typing{M}{A}
  &
  \typenvcon{x}{A} \vdash \typing{N}{B}
}
{\mathbf{let}}
{
  \env \vdash \typing{\expshr{x}{M}{N}}{B}
}
&
\inference
{
  \env \vdash \typing{M}{A}
  & 
  \env \vdash \typing{N}{B} 
}
{{\times}\intro}
{
  \env \vdash \typing{\expprd{M}{N}}{\typprd{A}{B}} 
}
\\~\\ 
\inference
{
  \env \vdash \typing{L}{\typprd{A}{B}} 
}
{{\times}\elim_1}
{
  \env \vdash \typing{\expfst{L}}{A}
}
&
\inference
{
  \env \vdash \typing{L}{\typprd{A}{B}} 
}
{{\times}\elim_2}
{
  \env \vdash \typing{\expsnd{L}}{B}
}
\\~\\
\inference
{
  \env \vdash \typing{M}{A}
}
{{+}\intro_1}
{
  \env \vdash \typing{\explft{M}{B}}{\typsum{A}{B}}
}
&
\inference
{
  \env \vdash \typing{N}{B} 
}
{{+}\intro_2}
{
  \env \vdash \typing{\exprgt{A}{N}}{\typsum{A}{B}}
}
\\~\\
\inference
{
  \env \vdash \typing{L}{\typsum{A}{B}} 
& 
  \typenvcon{x}{A} \vdash \typing{M}{C}  
& 
  \typenvcon{y}{B} \vdash \typing{N}{C}
}
{{+}\elim}
{
  \env \vdash \typing{\expcas{L}{x}{M}{y}{N}}{C} 
} 
\end{array}
\]
\caption{Typing Rules}
\label{fig:typing}
\end{figure*}

Typing rules are syntax-directed and algorithmic. The consistency of
the type system can be established by its correspondence (under
Curry-Howard) to minimal logic. The correspondece is made evident by using colored fonts in typing rules; removing the red bits (i.e. expressions) from the typing rules yields the corresponding logical inference rules.\\

Values are expressions that do not compute and they are identified by
the predicate defined in Figure~\ref{fig:val}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{lll}

\fbox{$\valuep{N}$}
\\~\\
\inference
{}
{variable}
{
  \valuep{\expvar{x}}
}
&
\inference
{}
{unit}
{
  \valuep{\expunt}
}
&
\inference
{
}
{abstraction}
{
  \valuep{\expabs{x}{A}{N}}
}
\\~\\
\inference
{
  \valuep{M} 
  &
  \valuep{N} 
}
{product}
{
  \valuep{\expprd{M}{N}}
}
&
\inference
{ 
  \valuep{M} 
}
{injection-left}
{
  \valuep{\explft{M}{B}}
}
&
\inference
{ 
  \valuep{N} 
}
{injection-right}
{
  \valuep{\exprgt{A}{N}}
}
\end{array}
\]
\caption{Values}
\label{fig:val}
\end{figure*}
  
Operational semantics is defined in Figure~\ref{fig:red}. The rewrite
rules are denoted as $\rewrite{}{}{}$. One-step reduction relaion,
denoted as $\reduce{}{}{}$, is compatible closure of rewrite
rules. Reduction relation, denoted as $\reducestar{}{}{}$, is
reflexive transitive closure of the one-step reduction relation. The
metavariables $F$ and $G$ denote capture-allowing evaluation frames,
used in rewrite rules. The metafunctions defined for expressions carry
over to evaluation frames trivially.
    
\begin{figure*}[h]
\[\uncolored
\begin{array}{@{}l@{}}
F \mathbin{\ ::=\ } \expapp{\hole}{M}\ |\ \expshr{x}{\hole}{N}\ |\ \expfst{\hole}\ |\ \expsnd{\hole}\ |\ \expcas{\hole}{x}{M}{y}{N}
\\[2pt]
G \mathbin{\ ::=\ } \explft{\hole} \ |\ \exprgt{\hole}\ |\ \expprd{\hole}{N}\ |\ \expprd{M}{\hole},\ \txt{if}\ \valuep{M}
\\[2pt]

\begin{array}[t]{@{}ll@{\ \rewrite{}{}{}\ \ }ll@{}} 
(let_{\rightarrow})  
& \expapp{(\expabs{x}{A}{N})}{M} 
& \expshr{x}{M}{N} 
& \\[0pt]  

(let_{+/\times})
& G[M]
& \expshr{x}{M}{G[x]}
& \cnd{x\ \txt{is\ fresh}}\\[0pt]

(\delta_{\times_1})  
& \expfst{\expprd{M}{N}} 
& M
& \\[0pt]

(\delta_{\times_2})  
& \expsnd{\expprd{M}{N}} 
& N                                               
& \\[0pt]

(\delta_{+_1}) 
& \expcasind{(\explft{L}{B})}{x}{M}{y}{N}
& \expshr{x}{L}{M}                             
& \\[0pt]

(\delta_{+_2})  
& \expcasind{(\exprgt{A}{L})}{x}{M}{y}{N}
& \expshr{y}{L}{N}                             
& \\[0pt]

(\beta/\eta_{let}) 
& \expshr{x}{M}{N}
& \sbs{N}{x}{M}  
& \cnd{Count(x,N) < 2,\ or\\\ \ \ \valuep{M}}\\[0pt]

(\Uparrow_{case})
& F[\expcasind{L}{x}{M}{y}{N}]
& \expcasind{L}{x}{F[M]}{y}{F[N]}
& \cnd{x \notin \fv{F},\ and\\\ \ \ y \notin \fv{F}}  \\[0pt]

(\Uparrow_{let})
& F[\expshr{x}{L}{M}]
& \expshr{x}{L}{F[M]} 
& \cnd{x \notin \fv{F}} \\[0pt]
\end{array}
\end{array}
\]
\caption{Reduction Rules}
\label{fig:red}
\end{figure*} 

\begin{proposition}[Confluency of Rewrite Rules]\ \\
\label{prop_confluency}
The rewrite rules in Figure~\ref{fig:red} form a confluent rewrite theory.
\end{proposition}

\begin{definition}[Normal Form]\ \\
An expression $M$ is in normal form, denoted as $Norm(M)$, if and only
if, does not exist an expression $N$ such that $\reduce{M}{}{N}$.
\end{definition}

\begin{proposition}[Normal Form Syntax]\ \\
\label{prop_normal}
An expression $M$ is in normal form, if and only if, it follows the
grammer in Figure~\ref{fig:nf}, by the entry $P$.
\end{proposition}
 
\begin{figure*}[h]
\[\uncolored
\begin{array}[t]{llll} 
(\txt{Neutral Forms}) & S & \mathbin{\ ::=\ } & \expvar{x}\ |\ R
\\
(\txt{Non-Value Neutral Forms}) & R & \mathbin{\ ::=\ } & \expapp{S}{P}\ |\ \expfst{S}\ |\ \expsnd{S}
\\
(\txt{Normal Values}) & V,W & \mathbin{\ ::=\ } & \expvar{x}\ |\ \expabs{x}{A}{Q}\ |\ \expunt\ |\ \expprd{V}{W}\ |\ \explft{V}{B}\ |\ \exprgt{A}{W}
\\
(\txt{Normal Forms}) & P,Q & \mathbin{\ ::=\ } & V\ |\ R\ |\ \expcas{S}{x}{P}{y}{Q} \\
& & \ | & \expshr{x}{R}{Q},\ \txt{if}\ count(x,Q)\geq2
\end{array}
\] 
\caption{Normal Forms}
\label{fig:nf}
\end{figure*} 

\begin{proposition}[Preservation]\ \\
\label{prop_preservation}
One-step reduction preserves the type of the source expression:
 
 if $\env \vdash \typing{M}{A}$ and $\reduce{M}{}{N}$, then 
$\env \vdash \typing{N}{A}$.
\end{proposition}

\begin{lemma}\ \\
\label{sub_S}
Type of an expression of neutral form, i.e. syntactic category $S$, is in the set of subformulae of types in the environment:
 
 if $\env \vdash \typing{S}{A}$, then $A \in \subformulae{\env}$.
\end{lemma}

\begin{proof}\ \\
By structural induction on $S$, we have the following cases:
\begin{description}
\item[Case ($\expvar{x}$):]\ \\ 
  The corresponding typing derivation concludes the result.
\item[Case ($R$):]\ \\
  Lemma \ref{sub_R} concludes the result.   
\end{description}

\end{proof}

\begin{lemma}\ \\
\label{sub_R}
Type of an expression of non-value neutral form, i.e. syntactic category $R$, is in the set of subformulae of types in the environment:
 
 if $\env \vdash \typing{R}{A}$, then $A \in \subformulae{\env}$.
\end{lemma}

\begin{proof}\ \\
By structural induction on $R$, we have the following cases:
\begin{description}
\item[Case ($\expapp{S}{P}$):]\ \\ 
  By the corresponding typing derivation and lemma \ref{sub_S}, we
  have $\typarr{A}{B} \in \subformulae{\Gamma}$, where $\typarr{A}{B}$
  is type of $S$ and $B$ type of the whole expression. Since $B \in
  \subformulae{\typarr{A}{B}}$, it concludes the result.
\item[Case ($\expfst{S}$):]\ \\
  By the corresponding typing derivation and lemma \ref{sub_S}, we
  have $\typprd{A}{B} \in \subformulae{\Gamma}$, where $\typprd{A}{B}$
  is type of $S$ and $A$ type of the whole expression. Since $A \in
  \subformulae{\typprd{A}{B}}$, it concludes the result.
\item[Case ($\expsnd{S}$):]\ \\
  By the corresponding typing derivation and lemma \ref{sub_S}, we
  have $\typprd{A}{B} \in \subformulae{\Gamma}$, where $\typprd{A}{B}$
  is type of $S$ and $B$ type of the whole expression. Since $B \in
  \subformulae{\typprd{A}{B}}$, it concludes the result.
\end{description}

\end{proof}

\begin{lemma}\ \\
\label{sub_V}
For a normal value $V$ and environment $\Gamma$, if $\Gamma \vdash \typing{V}{A}$,
then for every expression $V_i$ in the set of subexpressions of $V$ such
that $\Delta \vdash \typing{V_i}{A_i}$, $A_i$ is in the set of subformulae of
the type $A$, or in the set of subformulae of types in the
environment $\Gamma$.
\end{lemma}
\begin{proof}
By structural induction on $V$, we have the following cases:
\begin{description}
\item[Case ($\expvar{x}$):]\ \\ 
  The corresponding typing derivation concludes the result. 
\item[Case ($\expabs{x}{A}{Q}$):]\ \\ 
  By the corresponding typing derivation and lemma \ref{sub_P}, we
  have for every $A_i$ (type of the subexpression $Q_i$ in $Q$), that
  $A_i \in \subformulae{(\typenvcon{x}{A})}$, or $A_i \in
  \subformulae{B}$, where $\typarr{A}{B}$ is type of the whole
  expression. Since for every type $C$, we have
  \begin{enumerate}[(a)] 
     \item $(C \in \subformulae{A}) \vee (C \in \subformulae{B})$ implies $C \in \subformulae{\typarr{A}{B}}$
     \item $C \in \subformulae{(\typenvcon{x}{A})}$ implies $(C \in \subformulae{\Gamma}) \vee (C \in \subformulae{A})$
  \end{enumerate}
  it concludes the result.
\item[Case ($\expunt$):]\ \\ 
  The corresponding typing derivation concludes the result. 
\item[Case ($\expprd{V}{W}$):]\ \\ 
  By the corresponding typing derivation and lemma \ref{sub_V}
  (i.e. the induction hypothesis), we have for every $A_i$ (type of
  the subexpression $V_i$ in $V$), that $A_i \in
  \subformulae{\Gamma}$, or $A_i \in \subformulae{A}$,
  where $\typprd{A}{B}$ is type of the whole expression. We also have
  for every $B_i$ (type of the subexpression $W_i$ in $W$), that $B_i \in
  \subformulae{\Gamma}$, or $B_i \in \subformulae{B}$.
  Since for every type $C$, we have
  \begin{enumerate}[(a)] 
     \item $C \in \subformulae{A}$ implies $C \in \subformulae{\typprd{A}{B}}$
     \item $C \in \subformulae{B}$ implies $C \in \subformulae{\typprd{A}{B}}$
  \end{enumerate}
  it concludes the result.
\item[Case ($\explft{V}{B}$):]\ \\
  By the corresponding typing derivation and lemma \ref{sub_V}
  (i.e. the induction hypothesis), we have for every $A_i$ (type of
  the subexpression $V_i$ in $V$), that $A_i \in
  \subformulae{\Gamma}$, or $A_i \in \subformulae{A}$,
  where $\typsum{A}{B}$ is type of the whole expression.
  Since for every type $C$, we have
  \begin{enumerate}[(a)] 
     \item $C \in \subformulae{A}$ implies $C \in \subformulae{\typsum{A}{B}}$
  \end{enumerate}
  it concludes the result. 
\item[Case ($\exprgt{A}{W}$):]\ \\
  By the corresponding typing derivation and lemma \ref{sub_V}
  (i.e. the induction hypothesis), we have for every $B_i$ (type of
  the subexpression $W_i$ in $W$), that $B_i \in
  \subformulae{\Gamma}$, or $B_i \in \subformulae{B}$,
  where $\typsum{A}{B}$ is type of the whole expression.
  Since for every type $C$, we have
  \begin{enumerate}[(a)] 
     \item $C \in \subformulae{B}$ implies $C \in \subformulae{\typsum{A}{B}}$
  \end{enumerate}
  it concludes the result.
\end{description}
\end{proof}

\begin{lemma}\ \\
\label{sub_P}
For a normal form $P$ and environment $\Gamma$, if $\Gamma \vdash \typing{P}{A}$,
then for every expression $P_i$ in the set of subexpressions of $P$ such
that $\Delta \vdash \typing{P_i}{A_i}$, $A_i$ is in the set of subformulae of
the type $A$, or in the set of subformulae of types in the
environment $\Gamma$.
\end{lemma}
\begin{proof}
By structural induction on $P$, we have the following cases:
\begin{description}
\item[Case ($V$):]\ \\
  Lemma \ref{sub_V} concludes the result.
\item[Case ($R$):]\ \\
  Lemma \ref{sub_R} concludes the result.
\item[Case ($\expcas{S}{x}{P}{y}{Q}$):]\ \\
  By the corresponding typing derivation and lemma \ref{sub_S}, we
  have $\typsum{A}{B} \in \subformulae{\Gamma}$. We also have,
  together with lemma \ref{sub_P} (i.e. the induction hypothesis), for
  every $A_i$ (type of the subexpression $P_i$ in $P$), that $A_i \in
  \subformulae{\typenvcon{x}{A}}$, or $A_i \in \subformulae{C}$, where
  $C$ is type of the whole expression. Moreover, we have, together
  with lemma \ref{sub_P} (i.e. the induction hypothesis), for every
  $B_i$ (type of the subexpression $Q_i$ in $Q$), that $B_i \in
  \subformulae{\typenvcon{x}{B}}$, or $B_i \in \subformulae{C}$.
  Since for every type $D$, we have
  \begin{enumerate}[(a)] 
     \item $D \in \subformulae{\typsum{A}{B}}$ implies $(D \in \subformulae{A}) \vee (D \in \subformulae{B})$
     \item $D \in \subformulae{\typenvcon{x}{A}}$ implies $(D \in \subformulae{\Gamma}) \vee (D \in \subformulae{A})$\\ (for every variable $x$ and type $A$) 
  \end{enumerate}
  it concludes the result. 
\item[Case ($\expshr{x}{R}{Q}$):]\ \\
  By the corresponding typing derivation and lemma \ref{sub_R}, we
  have $A \in \subformulae{\Gamma}$, where $A$ is type of $R$. We also have, together with lemma \ref{sub_P} (i.e. the induction hypothesis), for
  every $B_i$ (type of the subexpression $Q_i$ in $Q$), that $B_i \in
  \subformulae{\typenvcon{x}{A}}$, or $B_i \in \subformulae{B}$, where
  $B$ is type of the whole expression. Since for every type $C$, we have
  \begin{enumerate}[(a)] 
     \item $C \in \subformulae{\typenvcon{x}{A}}$ implies $(C \in \subformulae{\Gamma}) \vee (C \in \subformulae{A})$
  \end{enumerate}
  it concludes the result.
\end{description}
\end{proof}

\begin{proposition}[Subformula Property]\ \\
\label{prop_subformula}
If $\Gamma \vdash \typing{M}{A}$, $\reducestar{M}{}{N}$, and $Norm(N)$;
then for every expression $L$ in the set of subexpressions of $N$ such
that $\Delta \vdash \typing{L}{C}$, $C$ is in the set of subterms of
the type $A$, or in the set of subterms of all types in the
environment $\Gamma$.
\end{proposition}
\begin{proof}
Proof is done by using proposition \ref{prop_preservation}, propostion \ref{prop_normal}, and lemma \ref{sub_P}.
\end{proof}
 
\end{document}
