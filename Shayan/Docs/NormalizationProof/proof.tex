\documentclass[11p,a4paper]{article}
%%\usepackage{lua-visual-debug}
\usepackage[round]{natbib}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mathtools}
\usepackage[pdfauthor={Shayan Najd},pdftitle={Modular Lazy Normaliser},pagebackref=true,pdftex]{hyperref}
\usepackage{titling}
\usepackage{pbox}
\usepackage{tabularx}
\newcommand{\incolor}[1]{#1}    % Use to typeset in color
%\newcommand{\incolor}[1]{}     % Use to typeset in black and white
 
% color framework

\newcommand{\judgecolor}{}
\newcommand{\typecolor}{}
\newcommand{\termcolor}{}
\newcommand{\Typecolor}{}
\newcommand{\Termcolor}{}

\newcommand{\uncolored}{
  \incolor{
    \renewcommand{\judgecolor}{}
    \renewcommand{\typecolor}{}
    \renewcommand{\termcolor}{}
    \renewcommand{\Typecolor}{}
    \renewcommand{\Termcolor}{}
  }
}

\newcommand{\colored}{
  \incolor{
    \renewcommand{\judgecolor}{\color{black}}
    \renewcommand{\typecolor}{\color{blue}}
    \renewcommand{\termcolor}{\color{red}}
    \renewcommand{\Typecolor}{\color{cyan}}
    \renewcommand{\Termcolor}{\color{magenta}}
  }
}

\newcommand{\jd}[1]{{\judgecolor #1}}
\newcommand{\tp}[1]{{\typecolor #1}}
\newcommand{\tm}[1]{{\termcolor #1}}
\newcommand{\Tp}[1]{{\Typecolor #1}}
\newcommand{\Tm}[1]{{\Termcolor #1}}

\newcommand{\tmof}[1]{\tm{#1:{}}}
\newcommand{\Tmof}[1]{\Tm{#1:{}}}
\newcommand{\tmsem}[1]{\tm{\sem{\Tm{#1}}}}
\newcommand{\tpsem}[1]{\tp{\sem{\Tp{#1}}}}
\newcommand{\tmSem}[1]{{\termcolor \left\llbracket
                        \judgecolor #1
                        \termcolor \right\rrbracket}}


%%
\newenvironment{note}{\begin{trivlist} \item \textbf{Note. }}{\end{trivlist}}
\newcommand{\todo}[1]{\textbf{#1}}
\newcommand{\etal}{\emph{et~al.}}
\newcommand{\inference}[3]{\infer[\mathsf{#2}]{#3}{#1}}
\newcommand{\Inference}[3]{\infer=[\mathsf{#2}]{#3}{#1}}
\newcommand{\spacer}{\quad\quad\quad\quad}
\newcommand{\filler}{\hspace{0.9\textwidth}}
\newcommand{\tighten}{\vspace{-1ex}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}{Definition}
\newcommand{\hole}{[\ ]}
\newcommand{\intro}{\mathcal{I}}
\newcommand{\elim}{\mathcal{E}}

%% Types
\newcommand{\typvar}[1]{#1}
\newcommand{\typunt}{\boldsymbol{\top}}
\newcommand{\typarr}[2]{#1\boldsymbol{\rightarrow}#2}
\newcommand{\typprd}[2]{#1\boldsymbol{\times}#2}
\newcommand{\typsum}[2]{#1\boldsymbol{+}#2}
\newcommand{\typrec}[2]{\boldsymbol{\mu}#1\boldsymbol{.}#2}

%% Expressions
\newcommand{\expvar}[1]{#1}
\newcommand{\expunt}{\boldsymbol{\top}}
\newcommand{\expabs}[3]{\boldsymbol{\lambda}\,#1\boldsymbol{\colon}#2\boldsymbol{.}\ #3}
\newcommand{\expapp}[2]{#1\ #2}
\newcommand{\expshr}[3]{\mathbf{let}\ #1\boldsymbol{=}#2\ \mathbf{in}\ #3} 
\newcommand{\expshrind}[3]{\begin{array}[t]{@{}l@{}}\mathbf{let}\ #1\boldsymbol{=}#2\\ \mathbf{in}\ \ #3\end{array}} 
\newcommand{\expprd}[2]{\boldsymbol{(}#1\ \boldsymbol{,}\ #2\boldsymbol{)}}
\newcommand{\expfst}[1]{\mathbf{fst}\ #1}
\newcommand{\expsnd}[1]{\mathbf{snd}\ #1}
\newcommand{\explft}[2]{\mathbf{inl}\ #1\ #2}
\newcommand{\exprgt}[2]{\mathbf{inr}\ #1\ #2}
\newcommand{\expcas}[5]{\mathbf{case}\ #1\ \mathbf{of}\ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}}
\newcommand{\expcasind}[5]{\begin{array}[t]{@{}l@{}}\mathbf{case}\ #1\ \mathbf{of}\\[-1pt] \ \ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}\end{array}}
\newcommand{\expcasindind}[5]{\begin{array}[t]{@{}l@{}}\mathbf{case}\ #1\ \mathbf{of}\\[-1pt] \ \ \ \ \boldsymbol{\{}\mathbf{inl}\ #2.\ #3\ \\[-1pt] \ \ \boldsymbol{;}\ \mathbf{inr}\ #4.\ #5\boldsymbol{\}}\end{array}}

%% Environment
\newcommand{\envemp}{\tp{\boldsymbol{\emptyset}}}
\newcommand{\envcon}[2]{\tp{#1,}\ #2}
\newcommand{\env}{\tp{\Gamma}}
\newcommand{\typing}[2]{\tm{#1:\ }\tp{#2}}

\newcommand{\typenvcon}[2]{\tp{\Gamma,}\ \typing{#1}{#2}}
\newcommand{\sbs}[3]{#1[#2:=#3]}
\newcommand{\fv}[1]{\txt{FV}\,(#1)}
\newcommand{\txt}[1]{\text{\emph{#1}}}
\newcommand{\reduce}[3]{#1 \overset{#2}\longrightarrow #3} 
\newcommand{\reducestar}[3]{#1 \overset{#2}\longrightarrow^* #3} 
\newcommand{\valuep}[1]{\txt{Value}\,(#1)}
\newcommand{\cnd}[1]{\begin{array}[t]{@{}l@{}}\txt{if}\ #1\end{array}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\setlength{\belowcaptionskip}{0pt}
\setlength{\abovecaptionskip}{0pt}
\setlength{\droptitle}{0pt} 
\addtolength{\droptitle}{-60pt}
\addtolength{\textheight}{50pt}
\addtolength{\textwidth}{125pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
%%\setlength{\marginparsep}{0pt}
%%\setlength{\marginparwidth}{0pt}

\begin{document}
\title{Modular Lazy Normalisation}
\author{Shayan Najd}
\maketitle 
\section*{Introduction}
In this article, I sketch design of a ``modular lazy normalisation''
algorithm.

The normalisation algorithm takes as input an expression and returns a
``semantically equivalent'' expression in ``normal form''. In
particular, we are interested in a normal form where all
$\beta$-redexes, and $\delta$-redexes corresponding to data
desctructors are eliminated.

Normalisation algorithm is ``lazy'' in the sense that elimination of
redexes does not duplicate expressions; it preserves sharing.

Normalisation algorithm is ``modular'' in the sense that the same
algorithm can be applied to a family of languages. Members of
the mentioned family of languages differ only in their set of built-in
functions and built-in types.

\section*{Step I -- No Polymorphism}
Variables are distinct set of names. Metavariables $x$, $y$, and $z$
range over variables. Wherever variables are used, renaming of bound
variables is allowed ; presentations are valid up to renamings.  

Types are \textbf{closed} terms defined by the abstract syntax in
Figure~\ref{fig:typ}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{llll}
A,B,C & \mathbin{\ ::=\ } 
%% & \tp{\typvar{X}}        & \textrm{variable}     \\
%% & \ |\ \ 
         & \typunt       & \textrm{unit}         \\
& \ |\ \ & \typarr{A}{B} & \textrm{abstraction}  \\
& \ |\ \ & \typprd{A}{B} & \textrm{product}      \\
& \ |\ \ & \typsum{A}{B} & \textrm{sum}       %% \\
%% & \ |\ \ & \tp{\typrec{X}{T}} & \textrm{recursion} 
\end{array}
\]\caption{Types}
\label{fig:typ}
\end{figure*}

Metavariables $A$, $B$, and $C$ range over types. Types correspond to
formule in minimal propositional logic.

%% and we restrict them to occure strictly
%% positive:
%% \todo{definition of strictly positive here}  
%% With exception of the recursion type, 
%% The recursion type is included to be able
%% to encode a wide range of datatypes which are otherwise built-in in
%% the language; every monomorphic datatype can be viewed as a recursive
%% sums of products. This general encoding enables us to provide
%% generic normalisation rules for data destructors. The generic rules
%% need to only consider three data destructors: two destructors for
%% products and one for sums. Since all data destructors are a combination
%% of the mentioned three data destructors, their corresponding
%% $\delta$-redexes are combinations of $\delta$-redexes corresponding to
%% the three data destructors. Therefore, by cooking in a set of
%% normalisation rules to eliminate $\delta$-redexes corresponding to the
%% three data destructors, we gaurantee removal of all $\delta$-redexes
%% corresponding to data destructors; there is no need to provide and
%% build in a separate set of $\delta-$reduction rules per each datatype.
 
Expressions are \textbf{open} terms defined by the abstract syntax in
Figure~\ref{fig:exp}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{llll}
L,M,N & \mathbin{\ ::=\ } 
         & \expvar{x}             & \textrm{variable}          \\
& \ |\ \ & \expunt                & \textrm{unit}              \\
& \ |\ \ & \expabs{x}{A}{N}      & \textrm{abstraction}       \\
& \ |\ \ & \expapp{L}{M}          & \textrm{application}       \\
& \ |\ \ & \expshr{x}{M}{N}       & \textrm{sharing}           \\
& \ |\ \ & \expprd{M}{N}          & \textrm{product}           \\
& \ |\ \ & \expfst{L}             & \textrm{projection-first}  \\
& \ |\ \ & \expsnd{L}             & \textrm{projection-second} \\ 
& \ |\ \ & \explft{M}{\tm{B}}     & \textrm{injection-left}    \\
& \ |\ \ & \exprgt{\tm{A}}{N}     & \textrm{injection-right}   \\
& \ |\ \ & \expcas{L}{x}{M}{y}{N} & \textrm{case}           
\end{array}
\]
\caption{Expressions}
\label{fig:exp}
\end{figure*}
 
Metavariables $L$, $M$, and $N$ range over expressions. Expressions
correspond to proofs in minimal propositional logic.

%Erasing the types, colored in red, yields the usual untyped
%$\lambda$-calculus.

Capture-free subsititution is defined as usual and it is denoted
as $\sbs{N}{x}{M}$ for subtitution of the expression $M$ for the
variable $x$ in the expression $N$. Set of free variables in an
expression is calculated as usual and it is denote as $\fv{N}$ for set
of free variables in $N$. Moreover, notion $count(x,N)$ is used to
denote a metafunction returning the number of times the free variable
$x$ is used in the term $N$.
% We follow Barendregt convension such that we assume variables in a
% term are all distinct. 
Typing, normalisation, and evaluation environments are all maps from
variable names. The metavariables $\Gamma$, and $\Delta$ range over
environments.  The inference rules are equivalent up to exchange,
contraction, and weakening operations.

Typing relations, denoted as $:$ infix operator, are defined by
the inference rules in Figure~\ref{fig:typing}.

\begin{figure*}[h]
\[\colored
\begin{array}{ll}
\fbox{$\env \vdash \typing{M}{A}$}
\\~\\
\inference
{}
{\mathbf{Ax}}
{
  \typenvcon{x}{A} \vdash \typing{x}{A}
}
&
\inference
{}
{\typunt}
{
   \env \vdash \typing{\expunt}{\typunt}
}
\\~\\
\inference
{
  \typenvcon{x}{A} \vdash \typing{N}{B} 
}
{{\to}\intro}
{
  \env \vdash \typing{\expabs{x}{A}{N}}{\typarr{A}{B}}
}
&
\inference
{
  \env \vdash \typing{L}{\typarr{A}{B}} 
& \env \vdash \typing{M}{A} 
}
{{\to}\elim}
{
  \env \vdash \typing{\expapp{L}{M}}{B} 
}
\\~\\ 
\inference
{
  \env \vdash \typing{M}{A}
  &
  \typenvcon{x}{A} \vdash \typing{N}{B}
}
{\mathbf{let}}
{
  \env \vdash \typing{\expshr{x}{M}{N}}{B}
}
&
\inference
{
  \env \vdash \typing{M}{A}
  & 
  \env \vdash \typing{N}{B} 
}
{{\times}\intro}
{
  \env \vdash \typing{\expprd{M}{N}}{\typprd{A}{B}} 
}
\\~\\ 
\inference
{
  \env \vdash \typing{L}{\typprd{A}{B}} 
}
{{\times}\elim_1}
{
  \env \vdash \typing{\expfst{L}}{A}
}
&
\inference
{
  \env \vdash \typing{L}{\typprd{A}{B}} 
}
{{\times}\elim_2}
{
  \env \vdash \typing{\expsnd{L}}{B}
}
\\~\\
\inference
{
  \env \vdash \typing{M}{A}
}
{{+}\intro_1}
{
  \env \vdash \typing{\explft{M}{B}}{\typsum{A}{B}}
}
&
\inference
{
  \env \vdash \typing{N}{B} 
}
{{+}\intro_2}
{
  \env \vdash \typing{\exprgt{A}{N}}{\typsum{A}{B}}
}
\\~\\
\inference
{
  \env \vdash \typing{L}{\typsum{A}{B}} 
& 
  \typenvcon{x}{A} \vdash \typing{M}{C}  
& 
  \typenvcon{y}{B} \vdash \typing{N}{C}
}
{{+}\elim}
{
  \env \vdash \typing{\expcas{L}{x}{M}{y}{N}}{C} 
} 
\end{array}
\]
\caption{Typing Rules}
\label{fig:typing}
\end{figure*}

Typing rules are syntax-directed and algorithmic. The consistency of
the type system can be established by its correspondence (under
Curry-Howard) to minimal logic.\\

Values are expressions that do not compute and they are identified by
the predicate defined in Figure~\ref{fig:val}.

\begin{figure*}[h]
\[\uncolored
\begin{array}{lll}

\fbox{$\valuep{N}$}
\\~\\
\inference
{}
{variable}
{
  \valuep{\expvar{x}}
}
&
\inference
{}
{unit}
{
  \valuep{\expunt}
}
&
\inference
{
}
{abstraction}
{
  \valuep{\expabs{x}{A}{N}}
}
\\~\\
\inference
{
  \valuep{M} 
  &
  \valuep{N} 
}
{product}
{
  \valuep{\expprd{M}{N}}
}
&
\inference
{ 
  \valuep{M} 
}
{injection-left}
{
  \valuep{\explft{M}{B}}
}
&
\inference
{ 
  \valuep{N} 
}
{injection-right}
{
  \valuep{\exprgt{A}{N}}
}
\end{array}
\]
\caption{Values}
\label{fig:val}
\end{figure*}

\subsection*{Call-By-Need}
  
%% Evaluation frames are defined by the abstract syntax in Figure~\ref{fig:evlfrm}.

%% \begin{figure*}
%% \[\uncolored
%% F \mathbin{\ ::=\ } \expapp{\hole}{M}\ |\ \expshr{x}{\hole}{N}\ |\ \expfst{\hole}\ |\ \expsnd{\hole}\ |\ \expcas{\hole}{x}{M}{y}{N}
%% \]
%% \caption{Evaluation Frame}
%% \label{fig:evlfrm}
%% \end{figure*}

Call-by-need reduction rules, denoted by $\reduce{}{l}{}$ infix
operator, are defined in Figure~\ref{fig:red}. Reflexive transivtive
closure of the reduction relation $\reduce{}{l}{}$ is denoted as
$\reducestar{}{l}{}$.
   
\begin{figure*}[h]
\[\uncolored
\begin{array}{@{}l@{}}
F \mathbin{\ ::=\ } \expapp{\hole}{M}\ |\ \expshr{x}{\hole}{N}\ |\ \expfst{\hole}\ |\ \expsnd{\hole}\ |\ \expcas{\hole}{x}{M}{y}{N}
\\[2pt]
G \mathbin{\ ::=\ } \explft{\hole} \ |\ \exprgt{\hole}\ |\ \expprd{\hole}{N}\ |\ \expprd{M}{\hole},\ \txt{if}\ \valuep{M}
\\[2pt]
\begin{array}[t]{@{}ll@{\ \reduce{}{l}{}\ \ }ll@{}} 
(let_{\rightarrow})  
& \expapp{(\expabs{x}{A}{N})}{M} 
& \expshr{x}{M}{N} 
& \\[0pt]  

(let_{+/\times})
& G[M]
& \expshr{x}{M}{G[x]}
& \cnd{x\ \txt{is\ fresh}}\\[0pt]

(\delta_{\times_1})  
& \expfst{\expprd{M}{N}} 
& M
& \\[0pt]

(\delta_{\times_2})  
& \expsnd{\expprd{M}{N}} 
& N                                               
& \\[0pt]

(\delta_{+_1}) 
& \expcasind{(\explft{L}{B})}{x}{M}{y}{N}
& \expshr{x}{L}{M}                             
& \\[0pt]

(\delta_{+_2})  
& \expcasind{(\exprgt{A}{L})}{x}{M}{y}{N}
& \expshr{y}{L}{N}                             
& \\[0pt]

(\beta/\eta_{let}) 
& \expshr{x}{M}{N}
& \sbs{N}{x}{M}  
& \cnd{Count(x,N) < 2,\ or\\\ \ \ \valuep{M}}\\[0pt]

(\Uparrow_{case})
& F[\expcasind{L}{x}{M}{y}{N}]
& \expcasind{L}{x}{F[M]}{y}{F[N]}
& \cnd{x \notin \fv{F},\ and\\\ \ \ y \notin \fv{F}}  \\[0pt]

(\Uparrow_{let})
& F[\expshr{x}{L}{M}]
& \expshr{x}{L}{F[M]} 
& \cnd{x \notin \fv{F}} \\[0pt]
\end{array}
\end{array}
\]
\caption{Reduction Rules}
\label{fig:red}
\end{figure*} 

\begin{proposition}[Confluency of Rewrite Rules]\ \\
The rewrite rules in Figure~\ref{fig:red} form a confluent rewrite theory.
\end{proposition}

\begin{definition}[Normal Form]\ \\
An expression $M$ is in normal form, denoted as $Norm(M)$, if and only
if, does not exist an expression $N$ such that $\reduce{M}{l}{N}$.
\end{definition}

\begin{proposition}[Normal Form Syntax]\ \\
An expression $M$ is in normal form, if and only if, it follows the
grammer in Figure~\ref{fig:nf}, by the entry $P$.
\end{proposition}
 
\begin{figure*}[h]
\[\uncolored
\begin{array}[t]{lll} 
S   & \mathbin{\ ::=\ } & \expvar{x}\ |\ R
\\
R   & \mathbin{\ ::=\ } & \expapp{S}{P}\ |\ \expfst{S}\ |\ \expsnd{S}
\\
V,W & \mathbin{\ ::=\ } & \expvar{x}\ |\ \expabs{x}{A}{Q}\ |\ \expunt\ |\ \expprd{V}{W}\ |\ \explft{V}{B}\ |\ \exprgt{A}{W}
\\
P,Q & \mathbin{\ ::=\ } & V\ |\ R\ |\ \expcas{S}{x}{P}{y}{Q} \\
& \ | & \expshr{x}{R}{Q},\ \txt{if}\ count(x,Q)\geq2
\end{array}
\] 
\caption{Normal Forms}
\label{fig:nf}
\end{figure*} 

\begin{proposition}[Preservation]\ \\
Reduction preserves the type of the source expression:
 
 if $\env \vdash \typing{M}{A}$ and $\reduce{M}{l}{N}$, then 
$\env \vdash \typing{N}{A}$.
\end{proposition}

\begin{proposition}[Subformula Property]\ \\
If $\Gamma \vdash \typing{M}{A}$, $\reducestar{M}{l}{N}$, and $Norm(N)$;
then for every expression $L$ in the set of subexpressions of $N$ such
that $\Delta \vdash \typing{L}{C}$, $C$ is in the set of subterms of
the type $A$, or in the set of subterms of all types in the
environment $\Gamma$.
\end{proposition}
 
\end{document}
