{-# OPTIONS_GHC -Wall -fno-warn-orphans #-}
{-# LANGUAGE GADTs,TypeFamilies,FlexibleInstances, TemplateHaskell #-}

module MiniFeldsparPrelude 
       ( true 
       , false 
       , while
       , forLoop  
       , (==)  
       , compare  
       , (<)  
       , (>=)  
       , (>)  
       , (<=)  
       , max  
       , min  
       , undef  
       , none  
       , option  
       , divO  
       , divTest  
       , len  
       , (<!>)  
       , zipWithVec  
       , sumVec  
       , scalarProd  
       , memorize  
       ) where

import Expression.MiniFeldspar
import qualified MiniFeldspar as MF
import Prelude hiding (Ord(..),Eq(..))
import qualified Prelude as P
import Data.Array
  
prelude = [ ('True  , MF.true)
          , ('False , MF.false)
          , ('(?)   , (MF.?))]
 
--ifC :: Exp Bool -> Exp a -> Exp a -> Exp a
 

(?) :: Bool -> (a , a) -> a
(?) = undefined

while ::  (Exp s -> Exp Bool) -> (Exp s -> Exp s ) -> Exp s -> Exp s
while = While 

forLoop :: Exp Int -> Exp s -> (Exp Int -> Exp s -> Exp s ) -> Exp s
forLoop ln int step = Snd $ while (\ (Pair i  _) -> i<ln )
                           (\ (Pair i  s) -> Pair (i+1) (step i s))
                           (Pair (0 :: Exp Int) int)  
                        
(==) :: P.Eq a => Exp a -> Exp a -> Exp Bool
(==) = Prim2 "==" (P.==)

compare :: P.Ord a => Exp a -> Exp a -> Exp Ordering
compare = Prim2 "compare" (P.compare)

(<) :: P.Ord a => Exp a -> Exp a -> Exp Bool
(<) = Prim2 "<" (P.<)

(>=) :: P.Ord a => Exp a -> Exp a -> Exp Bool
(>=) = Prim2 ">=" (P.>=)

(>) :: P.Ord a => Exp a -> Exp a -> Exp Bool
(>) = Prim2 ">" (P.>)

(<=) :: P.Ord a => Exp a -> Exp a -> Exp Bool
(<=) = Prim2 "<=" (P.<=)

max :: P.Ord a => Exp a -> Exp a -> Exp a
max = Prim2 "max" (P.max)

min :: P.Ord a => Exp a -> Exp a -> Exp a
min = Prim2 "min" (P.min)

instance Num a => Num (Exp a) where  
  (+) = Prim2 "+" (+)
  (-) = Prim2 "-" (-)
  (*) = Prim2 "-" (-)
  abs = Prim1 "abs" abs
  signum = Prim1 "signum" signum
  fromInteger = Value . fromInteger

data Option a = Option {isSome :: Exp Bool , fromSome :: a}
  
undef :: Exp a
undef = Undef  

some :: a -> Option a
some a = Optiontrue a

none :: Option (Exp a)
none = Option false undef

option :: Exp b -> (Exp a -> Exp b) -> Option (Exp a) -> Exp b
option noneCase someCase opt = ifC (isSome opt)
                               (someCase (fromSome opt ))
                               noneCase
                    
instance Functor Option where
  fmap f (Option b a) = Option b (f a)
  
instance Monad Option where
  return a = some a
  opt >>= k = b {isSome = isSome opt ? (isSome b , false ) }
    where b = k (fromSome opt)                               
            
divO :: Exp Int -> Exp Int -> Option (Exp Int )
divO f1 f2 = let
  Value x = f1 
  Value y = f2
  in if y P.== 0 
     then none
     else some $ LitI $ x `div` y
          
divTest :: Exp Int -> Exp Int -> Exp Int -> Option (Exp Int )
divTest a b c = do r1 <- divO a b
                   r2 <- divO a c
                   return (r1 + r2)          
                   
                   
len :: Exp (Array Int a) -> Exp Int
len arr = ArrLen arr

(<!>) ::  Exp (Array Int a) -> Exp Int -> Exp a
(<!>) = ArrIx                 

data Vector a where
  Indexed :: Exp Int -> (Exp Int -> a) -> Vector a
  
zipWithVec :: (Exp a -> Exp  b -> c) -> Vector (Exp a) 
              -> Vector (Exp b) -> Vector c
zipWithVec f (Indexed l1 ixf1 ) ( Indexed l2 ixf2 ) = 
  Indexed (min l1 l2 ) (\ ix -> f (ixf1 ix) (ixf2 ix))

sumVec :: (Num a) => Vector (Exp a) -> (Exp a)
sumVec (Indexed l ixf) = forLoop l 0 (\ ix s -> s + ixf ix )

instance Functor Vector where
  fmap f (Indexed l ixf) = Indexed l ( f . ixf )  
  
scalarProd :: Num a => Vector (Exp a) -> Vector (Exp a) -> Exp a
scalarProd a b = sumVec (zipWithVec (*) a b)

memorize :: Vector (Exp a) -> Vector (Exp a)
memorize (Indexed l ixf) = Indexed l (\ n -> Arr l ixf  <!> n)